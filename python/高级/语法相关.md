## 属性

对对象使用`.xxx`会调用`__getattribute__`方法，如果找不到会调用 `__getattr__`方法
`__getattribute__`内部不能使用`.xxx`，容易死循环

## GC

python的垃圾回收机制是以引用计数为主,加上标记-清除,分代收集等辅助方式组成的

引用计数被+1的情况:

1. 对象被创建
2. 对象被引用
3. 对象被作为参数，传入到一个函数中
4. 对象作为一个元素，存储在容器中

引用计数被-1的情况:

1. 对象的别名被赋予新的对象
2. 对象的别名被显式销毁
3. 一个对象离开它的作用域
4. 对象所在的容器被销毁，或从容器中删除对象

如果循环引用中，两个对象都定义了__del__方法，gc模块不会销毁这些不可达对象，因为gc模块不知道应该先调用哪个对象的__del__方法，所以为了安全起见，gc模块会把对象放到gc.garbage中，但是不会销毁对象
1. 项目中避免循环引用
2. 引入gc模块，启动gc模块的自动清理循环引用的对象机制
3. 由于分代收集，所以把需要长期使用的变量集中管理，并尽快移到二代以后，减少GC检查时的消耗
4. gc模块唯一处理不了的是循环引用的类都有__del__方法，所以项目中要避免定义__del__方法，如果一定要使用该方法，同时导致了循环引用，需要代码显式调用gc.garbage里面的对象的__del__来打破僵局

gc模快有一个自动垃圾回收的阀值，即通过`gc.get_threshold`函数获取到的长度为3的元组，例如(700,10,10)
每一次计数器的增加，gc模块就会检查增加后的计数是否达到阀值的数目，如果是，就会执行对应的代数的垃圾检查，然后重置计数器