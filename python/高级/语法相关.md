## 属性

对对象使用`.xxx`会调用`__getattribute__`方法，如果找不到会调用 `__getattr__`方法
`__getattribute__`内部不能使用`.xxx`，容易死循环

## 动态添加方法

```py
def printName(self):
    print('输出名字------%s----' %self.name)

@staticmethod
def printNameStatic():
    print('输出名字------111----')

Test.printName = printName

t = Test('Jack')
t.printName = types.MethodType(printName, t)
```
## __slots__

实例在创建出来之后,可以动态的添加属性和方法, 那如果想要限制添加的实例属性,可以使用 `__slots__`（仅会限制当前类）
如果某个类会大量创建，占用大量内存，也可以使用`__slots__`来给类的对象瘦身

## GC

python的垃圾回收机制是以引用计数为主,加上标记-清除,分代收集等辅助方式组成的

引用计数被+1的情况:

1. 对象被创建
2. 对象被引用
3. 对象被作为参数，传入到一个函数中
4. 对象作为一个元素，存储在容器中

引用计数被-1的情况:

1. 对象的别名被赋予新的对象
2. 对象的别名被显式销毁
3. 一个对象离开它的作用域
4. 对象所在的容器被销毁，或从容器中删除对象

如果循环引用中，两个对象都定义了__del__方法，gc模块不会销毁这些不可达对象，因为gc模块不知道应该先调用哪个对象的__del__方法，所以为了安全起见，gc模块会把对象放到gc.garbage中，但是不会销毁对象
1. 项目中避免循环引用
2. 引入gc模块，启动gc模块的自动清理循环引用的对象机制
3. 由于分代收集，所以把需要长期使用的变量集中管理，并尽快移到二代以后，减少GC检查时的消耗
4. gc模块唯一处理不了的是循环引用的类都有__del__方法，所以项目中要避免定义__del__方法，如果一定要使用该方法，同时导致了循环引用，需要代码显式调用gc.garbage里面的对象的__del__来打破僵局

gc模快有一个自动垃圾回收的阀值，即通过`gc.get_threshold`函数获取到的长度为3的元组，例如(700,10,10)
每一次计数器的增加，gc模块就会检查增加后的计数是否达到阀值的数目，如果是，就会执行对应的代数的垃圾检查，然后重置计数器

## 浅拷贝，深拷贝

copy: 相当于只是拷贝表面一层,如果里面还有深层次的引用,那么也是直接拷贝引用的地址,而且如果拷贝对象是不可变类型比如元组,那么也是直接拷贝引用.

deepcopy: 无论是拷贝可变类型还是不可变类型,无论是里面嵌套了多深层次的引用关系,统统复制一份,在新的空间中存储起来.